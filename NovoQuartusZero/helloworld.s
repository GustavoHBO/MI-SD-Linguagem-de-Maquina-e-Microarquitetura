.data
	# Mensagem de 1000 bytes armazenada.
msg:	.word 0xB0B59E13, 0x5EA0EC16, 0xA7A4DB80, 0x1DC83207, 0xE036EDAE, 0x54C33C45, 0x08DCB48E, 0x61C1F5CD, 0xF2C603C7, 0xD62DA490, 0xF1C18A77, 0xD0E5DEBB, 0x59BE5CFB, 0x12981CD3, 0x1E6B87ED, 0xBB1CD608, 0x3AF99C56, 0xD0A5EF9A, 0x8E93A77E, 0x89CA7906, 0x3C2AD4DC, 0x7346841D, 0x69FC120A, 0x33F044B5, 0x69F93223, 0xB6CB5EBA, 0x7ADE9EBA, 0x18ED1646, 0xCF12A850, 0x9F3E9899, 0x6FA5D2C6, 0x2CEB8947, 0x8748081D, 0x30BF1E6D, 0x009BDA3B, 0xB9BFE3D3, 0x22688666, 0x8AEF846F, 0x5398D895, 0x50584180, 0x4D56AEF6, 0xD9A3730C, 0x570E2BEB, 0xCF3F7689, 0xF6FAA6A1, 0xE9A818F4, 0x5DD7B794, 0x20F0FFD5, 0xE13CACD4, 0xABA98A86, 0xE18DC47A, 0x18075AF4, 0xE4A23F5B, 0x9CC4FE6D, 0x1CC38785, 0xA3F6B6D2, 0x0EFEDDCD, 0x64537227, 0x1315A0BB, 0x67E6FD54, 0x35813A62, 0x3A56FE1F, 0xFC546F12, 0x3E7154D1, 0xDDE36664, 0xCC037601, 0xA4E4625A, 0x3C09DC34, 0xEB700D7C, 0xF253E5B7, 0xE982388E, 0xE82D9EB6, 0xCF95B730, 0x18E008E0, 0xF8CC10C8, 0xD47F740C, 0x1AD1E849, 0x2006E343, 0xFC13222F, 0xD9CEC707, 0x30D89A45, 0x6F50F462, 0x24A5E480, 0x1A8D10AA, 0x7DBC3D30, 0x1F772039, 0xF8C7C8BA, 0x88A40964, 0x05114856, 0xE83A62C2, 0x2D55B509, 0x231ACCFF, 0xD6E7B328, 0x66DB1E4A, 0x4796F478, 0xDC4F0D49, 0x3F149911, 0x51662159, 0x1495253E, 0xDFF51662, 0xE24941F3, 0x13014F93, 0xFDBF87D8, 0x6627C320, 0x2909FB00, 0x2BC3DAE5, 0x79EA49C6, 0xFFD578A0, 0x8C366A16, 0xD513DEC4, 0x36B59D06, 0xF4DC08CE, 0xEF90DCBA, 0xE306D163, 0x2766A7EE, 0x80E5309F, 0xD5F5A03D, 0xA8071D2B, 0x45911BF0, 0x2E18E5B1, 0x9837601F, 0x53E04A44, 0xC10200DA, 0xCABC89A4, 0xECCB4990, 0x7703615F, 0xF62EDBEF, 0x44D1F158, 0x323C0B43, 0x7BDCA875, 0x75110A2E, 0x07068D7F, 0x4087272A, 0xB2320BD1, 0x315340F5, 0xBD130150, 0xC0E22CB2, 0xF63EBBCC, 0xB4C56CF2, 0xDC419684, 0xAA50FA14, 0xF09D8915, 0x09335DD6, 0x4A190ECD, 0x9A561777, 0x4218225C, 0xE49FF684, 0x1E0303BB, 0xED4749B5, 0xCEAB40AE, 0xBFEA1738, 0xE484B629, 0x477C4B68, 0x93E7E205, 0x4DDFC594, 0x562F17E6, 0xEBDA6D8C, 0xC2076013, 0x0F2E1A7A, 0x7CD2A216, 0xAF1AAC2C, 0x3E19566C, 0x582CEB46, 0x25CCFFFA, 0xFB52BF42, 0x824A57E1, 0x6BD4DB7E, 0x65E6F739, 0x6A803D7A, 0x45EBE1AA, 0xC06CC38F, 0x7532EB62, 0x85EA711E, 0x3E4E53CA, 0xB72AA558, 0x7CC94C62, 0x5CAFC451, 0x4032E2AC, 0xE49F4361, 0xA4118C94, 0xE47517C5, 0x54A44BAC, 0x8A449DB0, 0x8C60C122, 0x39DA5780, 0x74D373FD, 0xBC07BA94, 0x9FB7EB8E, 0x8664B5D6, 0xA3DA4552, 0x692A609D, 0xF97A9DDA, 0x0777A220, 0xD945BD94, 0x44F02372, 0xE98F3CF3, 0xFAA53102, 0xDAAC08CC, 0x9DCFC3D7, 0x8E72A260, 0x1FB95997, 0xCA674FE0, 0xC50AE9AA, 0xD53C2296, 0x67D4DEB8, 0xFD98B15D, 0xFC2B8B59, 0x943CC86A, 0x63D130EF, 0x30A5D332, 0x47873655, 0xBA9718F7, 0x9D5DE0BE, 0x817C4653, 0x807A3E3D, 0xA7EEA2DB, 0x1BC5DEA5, 0xEABA7B32, 0xBE0EFA93, 0x77B9E07C, 0x0763BCE6, 0x00FBF0DD, 0xDA767A6A, 0x0DF78B9B, 0x5AB7E28C, 0x03AE5FC8, 0xB7352FE6, 0x7822BE4B, 0x0D9B573B, 0xAB6D4307, 0x85E8898B, 0xADC1220B, 0x3F2FE9DD, 0x964BE9CD, 0x5C91BC6F, 0x64763CA3, 0x93FD70D2, 0x59CA3A1E, 0xEF629363, 0xD3B3D385, 0xAC387AB8, 0x142D5750, 0xC5FF2FCA, 0x5C0A540D, 0x97444FB3, 0x583EA726, 0xE81160A3, 0x14E862B1, 0xB819BC45, 0xA30E4B2B
.text
	# Declaração dos valores a serem utilizados
	
	# Definindo o topo da pilha
	movia r8, 0x1FBF

	# Definindo o polinômio, colocando-o no registador r18
	movia r18, 0x814141AB
	
	# Utilizado para identificar se o primeiro bit é 1
	movhi r19, 0b1000000000000000 
	
	# Define a quantidade de bits que ainda precisam ser calculados(Tamanho da mensagem - 32 + tamanho do polinômio do CRC)
	addi r20, r0, 8000
	
	# Define a quantidade de bits do polinômio
	addi r21, r0, 32
	
	# Carrega os registradores de mensagem e buffer a partir da memória.
	
	movia r23, msg # Define o endereço inicial de leitura.
	add r22, r0, r0 # Define o buffer como 0 bit's carregados.
	
	ldw r16, 0(r23) # Carrega os primeiros 32 bit's na mensagem.
	


	# Executa o procedimento inicial.
.global _start 
_start:
	call __calcularCRC32

	# Calcula o código CRC da mensagem armanenada no registrador r16 com o polinômio r18.
__calcularCRC32:
	bgeu r0, r20, __exibirCodigo # Verifica se ainda existe mensagem a ser calculada. Caso r0 seja maior que r20.
	call __prepararMensagem # Chama o procedimento para deslocar os bit's se necessário.
	xor r16, r16, r18 # Executa o XOR da mensagem com o polinômio.
	br __calcularCRC32 # Chama novamente o procedimento de calcular CRC32.
	
	# Prepara a mensagem para que seja feita a operação XOR da mensagem com o polinômio.
__prepararMensagem:
	bge r0, r20, __exibirCodigo # Verifica se ainda existe mensagem a ser calculada. Caso r0 seja maior que r20.
	bgtu r19, r16, __deslocarBit # Verifica se o bit mais significativo da mensagem é 0. Caso r19 seja maior ou igual a r16.
	stw r31, 0(r8)
	addi r8, r8, 4 # Incrementa o ponteiro para o topo da pilha.
	call __deslocarBit
	subi r8, r8, 4 # Decrementa o ponteiro para o topo da pilha.
	ldw r31, 0(r8)
	ret
	
	# Desloca o bit mais significativo da mensagem, carregando outro no menos significativo(dependendo do valor de r7).
__deslocarBit:
	slli r16, r16, 1 # Desloca um bit para a esquerda.
	subi r20, r20, 1 # Decrementa a quantidade de bit's a serem lidos.
	addi r4, r0, 0b100000
	bgeu r20, r4, __deslocarBuffer # Verifica se os bit's a serem deslocados são da mensagem ou do polinômio.
	movia r4, 0x1FC3
	beq r8, r4, __retornar # Verifica se deve retornar a chamada da instrução call no conjuto de intruções __calcularCRC32
	br __prepararMensagem

	# Verifica se o bit a ser carregado na mensagem é 1 ou 0 e se é necessário carregar novamente o buffer.
__deslocarBuffer:
	bgeu r0, r22, __carregarMensagem # Verifica se ainda tem mensagens a serem lidas no buffer. Caso r0 seja maior ou igual a r22.
	bgtu r19, r17, __deslocarUmBit # Verifica se o bit a ser deslocado é 1 ou 0. Caso r19 seja maior que r17.
	addi r16, r16, 1
	br __deslocarUmBit

	# Desloca um bit para esquerda do buffer.
__deslocarUmBit:
	slli r17, r17, 1 # Desloca para a esquerda um bit de r17.
	subi r22, r22, 1 # Decrementa em um bit a quantidade de bit's a serem lidos do buffer.
	movia r4, 0x1FC3
	beq r8, r4, __retornar
	br __prepararMensagem
	
	# Label de retorno
__retornar:
	ret

	# Carrega a mensagem da memória para o registrador buffer.
__carregarMensagem:
	sub r20, r20, r22 # Decrementa a quantidade de bits do buffer.
	addi r23, r23, 4 # Incrementa a posição de leitura dos próximos bytes a serem recuperados da memória.
	ldw r17, 0(r23) # Ler da memória os 32 bit's.
	bgtu r21, r20, __quantidadeBitLer # Verifica se a quantidade de bit's a serem lidos na memória é menor que 32.
	addi r22, r0, 32 # Quantidade de bit's recuperados da memória.
	br __deslocarBuffer # Vai para o conjunto de instruções de deslocar bit's do buffer.

	# Determina a quantidade de bits que faltam ser calculados. Caso esse valor seja menor que 32.
__quantidadeBitLer:
	mov r22, r20
	br __deslocarBuffer # Vai para o conjunto de instruções de deslocar bit's do buffer. 
	
	# Exibe o CRC calculado nos 4 LEDs, intercalando-os com os botões. O botão mais significativo encerra o processo.

__exibirCodigo: 
		movia r12, 0x3010
		movia r14, 0x3000
		movia r5, 900000 #Contador para delay
		movi r6, 1
		movi r8, 4

checando_botao:		
		ldb r9, 0(r14)
		beq r9, r6, exibe_dados
		br checando_botao

exibe_dados:	
		stb r16, 0(r12)
		ror r16, r16, r8 #Move os últimos 4 bits para direita
		movia r5, 900000 #Reinicia contador do delay
		call delay

delay:		
		subi r5, r5, 1
		bne r5, r0, delay
		call checando_botao

end:
	br end
	.end